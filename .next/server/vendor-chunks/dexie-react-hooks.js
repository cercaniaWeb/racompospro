"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/dexie-react-hooks";
exports.ids = ["vendor-chunks/dexie-react-hooks"];
exports.modules = {

/***/ "(ssr)/./node_modules/dexie-react-hooks/dist/dexie-react-hooks.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/dexie-react-hooks/dist/dexie-react-hooks.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useDocument: () => (/* binding */ useDocument),\n/* harmony export */   useLiveQuery: () => (/* binding */ useLiveQuery),\n/* harmony export */   useObservable: () => (/* binding */ useObservable),\n/* harmony export */   usePermissions: () => (/* binding */ usePermissions)\n/* harmony export */ });\n/* harmony import */ var dexie__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dexie */ \"(ssr)/./node_modules/dexie/import-wrapper.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n\n\nfunction useObservable(observableFactory, arg2, arg3) {\n    // Resolve vars from overloading variants of this function:\n    var deps;\n    var defaultResult;\n    if (typeof observableFactory === 'function') {\n        deps = arg2 || [];\n        defaultResult = arg3;\n    }\n    else {\n        deps = [];\n        defaultResult = arg2;\n    }\n    // Create a ref that keeps the state we need\n    var monitor = react__WEBPACK_IMPORTED_MODULE_1__.useRef({\n        hasResult: false,\n        result: defaultResult,\n        error: null,\n    });\n    // We control when component should rerender. Make triggerUpdate\n    // as examplified on React's docs at:\n    // https://reactjs.org/docs/hooks-faq.html#is-there-something-like-forceupdate\n    var _a = react__WEBPACK_IMPORTED_MODULE_1__.useReducer(function (x) { return x + 1; }, 0); _a[0]; var triggerUpdate = _a[1];\n    // Memoize the observable based on deps\n    var observable = react__WEBPACK_IMPORTED_MODULE_1__.useMemo(function () {\n        // Make it remember previous subscription's default value when\n        // resubscribing.\n        var observable = typeof observableFactory === 'function'\n            ? observableFactory()\n            : observableFactory;\n        if (!observable || typeof observable.subscribe !== 'function') {\n            if (observableFactory === observable) {\n                throw new TypeError(\"Given argument to useObservable() was neither a valid observable nor a function.\");\n            }\n            else {\n                throw new TypeError(\"Observable factory given to useObservable() did not return a valid observable.\");\n            }\n        }\n        if (!monitor.current.hasResult &&\n            typeof window !== 'undefined' // Don't do this in SSR\n        ) {\n            // Optimize for BehaviorSubject and other observables implementing getValue():\n            if (typeof observable.hasValue !== 'function' || observable.hasValue()) {\n                if (typeof observable.getValue === 'function') {\n                    monitor.current.result = observable.getValue();\n                    monitor.current.hasResult = true;\n                }\n                else {\n                    // Find out if the observable has a current value: try get it by subscribing and\n                    // unsubscribing synchronously\n                    var subscription = observable.subscribe(function (val) {\n                        monitor.current.result = val;\n                        monitor.current.hasResult = true;\n                    });\n                    // Unsubscribe directly. We only needed any synchronous value if it was possible.\n                    if (typeof subscription === 'function') {\n                        subscription();\n                    }\n                    else {\n                        subscription.unsubscribe();\n                    }\n                }\n            }\n        }\n        return observable;\n    }, deps);\n    // Integrate with react devtools:\n    react__WEBPACK_IMPORTED_MODULE_1__.useDebugValue(monitor.current.result);\n    // Subscribe to the observable\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect(function () {\n        var subscription = observable.subscribe(function (val) {\n            var current = monitor.current;\n            if (current.error !== null || current.result !== val) {\n                current.error = null;\n                current.result = val;\n                current.hasResult = true;\n                triggerUpdate();\n            }\n        }, function (err) {\n            var current = monitor.current;\n            if (current.error !== err) {\n                current.error = err;\n                triggerUpdate();\n            }\n        });\n        return typeof subscription === 'function'\n            ? subscription // Support observables that return unsubscribe directly\n            : subscription.unsubscribe.bind(subscription);\n    }, deps);\n    // Throw if observable has emitted error so that\n    // an ErrorBoundrary can catch it\n    if (monitor.current.error)\n        throw monitor.current.error;\n    // Return the current result\n    return monitor.current.result;\n}\n\nfunction useLiveQuery(querier, deps, defaultResult) {\n    return useObservable(function () { return dexie__WEBPACK_IMPORTED_MODULE_0__.Dexie.liveQuery(querier); }, deps || [], defaultResult);\n}\n\nfunction usePermissions(firstArg, table, obj) {\n    if (!firstArg)\n        throw new TypeError(\"Invalid arguments to usePermissions(): undefined or null\");\n    var db;\n    if (arguments.length >= 3) {\n        if (!('transaction' in firstArg)) {\n            // Using ducktyping instead of instanceof in case there are multiple Dexie modules in app.\n            // First arg is  ensures first arg is a Dexie instance\n            throw new TypeError(\"Invalid arguments to usePermission(db, table, obj): 1st arg must be a Dexie instance\");\n        }\n        if (typeof table !== 'string')\n            throw new TypeError(\"Invalid arguments to usePermission(db, table, obj): 2nd arg must be string\");\n        if (!obj || typeof obj !== 'object')\n            throw new TypeError(\"Invalid arguments to usePermission(db, table, obj): 3rd arg must be an object\");\n        db = firstArg;\n    }\n    else {\n        if (firstArg instanceof dexie__WEBPACK_IMPORTED_MODULE_0__.Dexie)\n            throw new TypeError(\"Invalid arguments to usePermission(db, table, obj): Missing table and obj arguments.\");\n        if (typeof firstArg.table === 'function' &&\n            typeof firstArg.db === 'object') {\n            db = firstArg.db;\n            obj = firstArg;\n            table = firstArg.table();\n        }\n        else {\n            throw new TypeError(\"Invalid arguments to usePermissions(). \" +\n                \"Expected usePermissions(entity: DexieCloudEntity) or \" +\n                \"usePermissions(db: Dexie, table: string, obj: DexieCloudObject)\");\n        }\n    }\n    if (!('cloud' in db))\n        throw new Error(\"usePermissions() is only for Dexie Cloud but there's no dexie-cloud-addon active in given db.\");\n    if (!('permissions' in db.cloud))\n        throw new Error(\"usePermissions() requires a newer version of dexie-cloud-addon. Please upgrade it.\");\n    return useObservable(\n    // @ts-ignore\n    function () { return db.cloud.permissions(obj, table); }, [obj.realmId, obj.owner, table]);\n}\n\nvar gracePeriod = 100; // 100 ms = grace period to optimize for unload/reload scenarios\nvar fr = typeof FinalizationRegistry !== 'undefined' && new FinalizationRegistry(function (doc) {\n    // If coming here, react effect never ran. This is a fallback cleanup mechanism.\n    var DexieYProvider = dexie__WEBPACK_IMPORTED_MODULE_0__.Dexie['DexieYProvider'];\n    if (DexieYProvider)\n        DexieYProvider.release(doc);\n});\nfunction useDocument(doc) {\n    var _a, _b;\n    if (!fr)\n        throw new TypeError('FinalizationRegistry not supported.');\n    var providerRef = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n    var DexieYProvider = dexie__WEBPACK_IMPORTED_MODULE_0__.Dexie['DexieYProvider'];\n    if (!DexieYProvider) {\n        throw new Error('DexieYProvider is not available. Make sure `y-dexie` is installed and imported.');\n    }\n    var unregisterToken = undefined;\n    if (doc) {\n        if (doc !== ((_a = providerRef.current) === null || _a === void 0 ? void 0 : _a.doc)) {\n            providerRef.current = DexieYProvider.load(doc, { gracePeriod: gracePeriod });\n            unregisterToken = Object.create(null);\n            fr.register(providerRef, doc, unregisterToken);\n        }\n    }\n    else if ((_b = providerRef.current) === null || _b === void 0 ? void 0 : _b.doc) {\n        providerRef.current = null;\n    }\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect(function () {\n        if (doc) {\n            // Doc is set or changed. Unregister provider from FinalizationRegistry\n            // and instead take over from here to release the doc when component is unmounted\n            // or when doc is changed. What we're doing here is to avoid relying on FinalizationRegistry\n            // in all the normal cases and instead rely on React's lifecycle to release the doc.\n            // But there can be situations when react never calls this effect and therefore, we\n            // need to rely on FinalizationRegistry to release the doc as a fallback.\n            // We cannot wait with loading the document until the effect happens, because the doc\n            // could have been destroyed in the meantime.\n            if (unregisterToken)\n                fr.unregister(unregisterToken);\n            var provider = DexieYProvider.for(doc);\n            if (provider) {\n                return function () {\n                    DexieYProvider.release(doc);\n                };\n            }\n            else {\n                // Maybe the doc was destroyed in the meantime.\n                // Can not happen if React and FinalizationRegistry works as we expect them to.\n                // Except if a user had called DexieYProvider.release() on the doc\n                throw new Error(\"FATAL. DexieYProvider.release() has been called somewhere in application code, making us lose the document.\");\n            }\n        }\n    }, [doc, unregisterToken]);\n    return providerRef.current;\n}\n\n\n//# sourceMappingURL=dexie-react-hooks.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZGV4aWUtcmVhY3QtaG9va3MvZGlzdC9kZXhpZS1yZWFjdC1ob29rcy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQThCO0FBQ0o7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHlDQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxhQUFhLDZDQUFnQixnQkFBZ0IsZUFBZSxNQUFNLE9BQU87QUFDekU7QUFDQSxxQkFBcUIsMENBQWE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLElBQUksZ0RBQW1CO0FBQ3ZCO0FBQ0EsSUFBSSw0Q0FBZTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXVDLE9BQU8sd0NBQUssc0JBQXNCO0FBQ3pFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msd0NBQUs7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsMENBQTBDO0FBQzVEOztBQUVBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EseUJBQXlCLHdDQUFLO0FBQzlCO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IseUNBQVk7QUFDbEMseUJBQXlCLHdDQUFLO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCwwQkFBMEI7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDRDQUFlO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVvRTtBQUNwRSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlY29vbS1wb3MvLi9ub2RlX21vZHVsZXMvZGV4aWUtcmVhY3QtaG9va3MvZGlzdC9kZXhpZS1yZWFjdC1ob29rcy5tanM/YWMxZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEZXhpZSB9IGZyb20gJ2RleGllJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmZ1bmN0aW9uIHVzZU9ic2VydmFibGUob2JzZXJ2YWJsZUZhY3RvcnksIGFyZzIsIGFyZzMpIHtcbiAgICAvLyBSZXNvbHZlIHZhcnMgZnJvbSBvdmVybG9hZGluZyB2YXJpYW50cyBvZiB0aGlzIGZ1bmN0aW9uOlxuICAgIHZhciBkZXBzO1xuICAgIHZhciBkZWZhdWx0UmVzdWx0O1xuICAgIGlmICh0eXBlb2Ygb2JzZXJ2YWJsZUZhY3RvcnkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZGVwcyA9IGFyZzIgfHwgW107XG4gICAgICAgIGRlZmF1bHRSZXN1bHQgPSBhcmczO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZGVwcyA9IFtdO1xuICAgICAgICBkZWZhdWx0UmVzdWx0ID0gYXJnMjtcbiAgICB9XG4gICAgLy8gQ3JlYXRlIGEgcmVmIHRoYXQga2VlcHMgdGhlIHN0YXRlIHdlIG5lZWRcbiAgICB2YXIgbW9uaXRvciA9IFJlYWN0LnVzZVJlZih7XG4gICAgICAgIGhhc1Jlc3VsdDogZmFsc2UsXG4gICAgICAgIHJlc3VsdDogZGVmYXVsdFJlc3VsdCxcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgfSk7XG4gICAgLy8gV2UgY29udHJvbCB3aGVuIGNvbXBvbmVudCBzaG91bGQgcmVyZW5kZXIuIE1ha2UgdHJpZ2dlclVwZGF0ZVxuICAgIC8vIGFzIGV4YW1wbGlmaWVkIG9uIFJlYWN0J3MgZG9jcyBhdDpcbiAgICAvLyBodHRwczovL3JlYWN0anMub3JnL2RvY3MvaG9va3MtZmFxLmh0bWwjaXMtdGhlcmUtc29tZXRoaW5nLWxpa2UtZm9yY2V1cGRhdGVcbiAgICB2YXIgX2EgPSBSZWFjdC51c2VSZWR1Y2VyKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4ICsgMTsgfSwgMCk7IF9hWzBdOyB2YXIgdHJpZ2dlclVwZGF0ZSA9IF9hWzFdO1xuICAgIC8vIE1lbW9pemUgdGhlIG9ic2VydmFibGUgYmFzZWQgb24gZGVwc1xuICAgIHZhciBvYnNlcnZhYmxlID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIE1ha2UgaXQgcmVtZW1iZXIgcHJldmlvdXMgc3Vic2NyaXB0aW9uJ3MgZGVmYXVsdCB2YWx1ZSB3aGVuXG4gICAgICAgIC8vIHJlc3Vic2NyaWJpbmcuXG4gICAgICAgIHZhciBvYnNlcnZhYmxlID0gdHlwZW9mIG9ic2VydmFibGVGYWN0b3J5ID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICA/IG9ic2VydmFibGVGYWN0b3J5KClcbiAgICAgICAgICAgIDogb2JzZXJ2YWJsZUZhY3Rvcnk7XG4gICAgICAgIGlmICghb2JzZXJ2YWJsZSB8fCB0eXBlb2Ygb2JzZXJ2YWJsZS5zdWJzY3JpYmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGlmIChvYnNlcnZhYmxlRmFjdG9yeSA9PT0gb2JzZXJ2YWJsZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHaXZlbiBhcmd1bWVudCB0byB1c2VPYnNlcnZhYmxlKCkgd2FzIG5laXRoZXIgYSB2YWxpZCBvYnNlcnZhYmxlIG5vciBhIGZ1bmN0aW9uLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJPYnNlcnZhYmxlIGZhY3RvcnkgZ2l2ZW4gdG8gdXNlT2JzZXJ2YWJsZSgpIGRpZCBub3QgcmV0dXJuIGEgdmFsaWQgb2JzZXJ2YWJsZS5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtb25pdG9yLmN1cnJlbnQuaGFzUmVzdWx0ICYmXG4gICAgICAgICAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAvLyBEb24ndCBkbyB0aGlzIGluIFNTUlxuICAgICAgICApIHtcbiAgICAgICAgICAgIC8vIE9wdGltaXplIGZvciBCZWhhdmlvclN1YmplY3QgYW5kIG90aGVyIG9ic2VydmFibGVzIGltcGxlbWVudGluZyBnZXRWYWx1ZSgpOlxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvYnNlcnZhYmxlLmhhc1ZhbHVlICE9PSAnZnVuY3Rpb24nIHx8IG9ic2VydmFibGUuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JzZXJ2YWJsZS5nZXRWYWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBtb25pdG9yLmN1cnJlbnQucmVzdWx0ID0gb2JzZXJ2YWJsZS5nZXRWYWx1ZSgpO1xuICAgICAgICAgICAgICAgICAgICBtb25pdG9yLmN1cnJlbnQuaGFzUmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZpbmQgb3V0IGlmIHRoZSBvYnNlcnZhYmxlIGhhcyBhIGN1cnJlbnQgdmFsdWU6IHRyeSBnZXQgaXQgYnkgc3Vic2NyaWJpbmcgYW5kXG4gICAgICAgICAgICAgICAgICAgIC8vIHVuc3Vic2NyaWJpbmcgc3luY2hyb25vdXNseVxuICAgICAgICAgICAgICAgICAgICB2YXIgc3Vic2NyaXB0aW9uID0gb2JzZXJ2YWJsZS5zdWJzY3JpYmUoZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9uaXRvci5jdXJyZW50LnJlc3VsdCA9IHZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vbml0b3IuY3VycmVudC5oYXNSZXN1bHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVW5zdWJzY3JpYmUgZGlyZWN0bHkuIFdlIG9ubHkgbmVlZGVkIGFueSBzeW5jaHJvbm91cyB2YWx1ZSBpZiBpdCB3YXMgcG9zc2libGUuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc3Vic2NyaXB0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYnNlcnZhYmxlO1xuICAgIH0sIGRlcHMpO1xuICAgIC8vIEludGVncmF0ZSB3aXRoIHJlYWN0IGRldnRvb2xzOlxuICAgIFJlYWN0LnVzZURlYnVnVmFsdWUobW9uaXRvci5jdXJyZW50LnJlc3VsdCk7XG4gICAgLy8gU3Vic2NyaWJlIHRvIHRoZSBvYnNlcnZhYmxlXG4gICAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IG9ic2VydmFibGUuc3Vic2NyaWJlKGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50ID0gbW9uaXRvci5jdXJyZW50O1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQuZXJyb3IgIT09IG51bGwgfHwgY3VycmVudC5yZXN1bHQgIT09IHZhbCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQuZXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgICAgIGN1cnJlbnQucmVzdWx0ID0gdmFsO1xuICAgICAgICAgICAgICAgIGN1cnJlbnQuaGFzUmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyVXBkYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50ID0gbW9uaXRvci5jdXJyZW50O1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQuZXJyb3IgIT09IGVycikge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQuZXJyb3IgPSBlcnI7XG4gICAgICAgICAgICAgICAgdHJpZ2dlclVwZGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBzdWJzY3JpcHRpb24gPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgID8gc3Vic2NyaXB0aW9uIC8vIFN1cHBvcnQgb2JzZXJ2YWJsZXMgdGhhdCByZXR1cm4gdW5zdWJzY3JpYmUgZGlyZWN0bHlcbiAgICAgICAgICAgIDogc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlLmJpbmQoc3Vic2NyaXB0aW9uKTtcbiAgICB9LCBkZXBzKTtcbiAgICAvLyBUaHJvdyBpZiBvYnNlcnZhYmxlIGhhcyBlbWl0dGVkIGVycm9yIHNvIHRoYXRcbiAgICAvLyBhbiBFcnJvckJvdW5kcmFyeSBjYW4gY2F0Y2ggaXRcbiAgICBpZiAobW9uaXRvci5jdXJyZW50LmVycm9yKVxuICAgICAgICB0aHJvdyBtb25pdG9yLmN1cnJlbnQuZXJyb3I7XG4gICAgLy8gUmV0dXJuIHRoZSBjdXJyZW50IHJlc3VsdFxuICAgIHJldHVybiBtb25pdG9yLmN1cnJlbnQucmVzdWx0O1xufVxuXG5mdW5jdGlvbiB1c2VMaXZlUXVlcnkocXVlcmllciwgZGVwcywgZGVmYXVsdFJlc3VsdCkge1xuICAgIHJldHVybiB1c2VPYnNlcnZhYmxlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIERleGllLmxpdmVRdWVyeShxdWVyaWVyKTsgfSwgZGVwcyB8fCBbXSwgZGVmYXVsdFJlc3VsdCk7XG59XG5cbmZ1bmN0aW9uIHVzZVBlcm1pc3Npb25zKGZpcnN0QXJnLCB0YWJsZSwgb2JqKSB7XG4gICAgaWYgKCFmaXJzdEFyZylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXJndW1lbnRzIHRvIHVzZVBlcm1pc3Npb25zKCk6IHVuZGVmaW5lZCBvciBudWxsXCIpO1xuICAgIHZhciBkYjtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSB7XG4gICAgICAgIGlmICghKCd0cmFuc2FjdGlvbicgaW4gZmlyc3RBcmcpKSB7XG4gICAgICAgICAgICAvLyBVc2luZyBkdWNrdHlwaW5nIGluc3RlYWQgb2YgaW5zdGFuY2VvZiBpbiBjYXNlIHRoZXJlIGFyZSBtdWx0aXBsZSBEZXhpZSBtb2R1bGVzIGluIGFwcC5cbiAgICAgICAgICAgIC8vIEZpcnN0IGFyZyBpcyAgZW5zdXJlcyBmaXJzdCBhcmcgaXMgYSBEZXhpZSBpbnN0YW5jZVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXJndW1lbnRzIHRvIHVzZVBlcm1pc3Npb24oZGIsIHRhYmxlLCBvYmopOiAxc3QgYXJnIG11c3QgYmUgYSBEZXhpZSBpbnN0YW5jZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRhYmxlICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGFyZ3VtZW50cyB0byB1c2VQZXJtaXNzaW9uKGRiLCB0YWJsZSwgb2JqKTogMm5kIGFyZyBtdXN0IGJlIHN0cmluZ1wiKTtcbiAgICAgICAgaWYgKCFvYmogfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhcmd1bWVudHMgdG8gdXNlUGVybWlzc2lvbihkYiwgdGFibGUsIG9iaik6IDNyZCBhcmcgbXVzdCBiZSBhbiBvYmplY3RcIik7XG4gICAgICAgIGRiID0gZmlyc3RBcmc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoZmlyc3RBcmcgaW5zdGFuY2VvZiBEZXhpZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGFyZ3VtZW50cyB0byB1c2VQZXJtaXNzaW9uKGRiLCB0YWJsZSwgb2JqKTogTWlzc2luZyB0YWJsZSBhbmQgb2JqIGFyZ3VtZW50cy5cIik7XG4gICAgICAgIGlmICh0eXBlb2YgZmlyc3RBcmcudGFibGUgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgIHR5cGVvZiBmaXJzdEFyZy5kYiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGRiID0gZmlyc3RBcmcuZGI7XG4gICAgICAgICAgICBvYmogPSBmaXJzdEFyZztcbiAgICAgICAgICAgIHRhYmxlID0gZmlyc3RBcmcudGFibGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGFyZ3VtZW50cyB0byB1c2VQZXJtaXNzaW9ucygpLiBcIiArXG4gICAgICAgICAgICAgICAgXCJFeHBlY3RlZCB1c2VQZXJtaXNzaW9ucyhlbnRpdHk6IERleGllQ2xvdWRFbnRpdHkpIG9yIFwiICtcbiAgICAgICAgICAgICAgICBcInVzZVBlcm1pc3Npb25zKGRiOiBEZXhpZSwgdGFibGU6IHN0cmluZywgb2JqOiBEZXhpZUNsb3VkT2JqZWN0KVwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoISgnY2xvdWQnIGluIGRiKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidXNlUGVybWlzc2lvbnMoKSBpcyBvbmx5IGZvciBEZXhpZSBDbG91ZCBidXQgdGhlcmUncyBubyBkZXhpZS1jbG91ZC1hZGRvbiBhY3RpdmUgaW4gZ2l2ZW4gZGIuXCIpO1xuICAgIGlmICghKCdwZXJtaXNzaW9ucycgaW4gZGIuY2xvdWQpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1c2VQZXJtaXNzaW9ucygpIHJlcXVpcmVzIGEgbmV3ZXIgdmVyc2lvbiBvZiBkZXhpZS1jbG91ZC1hZGRvbi4gUGxlYXNlIHVwZ3JhZGUgaXQuXCIpO1xuICAgIHJldHVybiB1c2VPYnNlcnZhYmxlKFxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBkYi5jbG91ZC5wZXJtaXNzaW9ucyhvYmosIHRhYmxlKTsgfSwgW29iai5yZWFsbUlkLCBvYmoub3duZXIsIHRhYmxlXSk7XG59XG5cbnZhciBncmFjZVBlcmlvZCA9IDEwMDsgLy8gMTAwIG1zID0gZ3JhY2UgcGVyaW9kIHRvIG9wdGltaXplIGZvciB1bmxvYWQvcmVsb2FkIHNjZW5hcmlvc1xudmFyIGZyID0gdHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ICE9PSAndW5kZWZpbmVkJyAmJiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkoZnVuY3Rpb24gKGRvYykge1xuICAgIC8vIElmIGNvbWluZyBoZXJlLCByZWFjdCBlZmZlY3QgbmV2ZXIgcmFuLiBUaGlzIGlzIGEgZmFsbGJhY2sgY2xlYW51cCBtZWNoYW5pc20uXG4gICAgdmFyIERleGllWVByb3ZpZGVyID0gRGV4aWVbJ0RleGllWVByb3ZpZGVyJ107XG4gICAgaWYgKERleGllWVByb3ZpZGVyKVxuICAgICAgICBEZXhpZVlQcm92aWRlci5yZWxlYXNlKGRvYyk7XG59KTtcbmZ1bmN0aW9uIHVzZURvY3VtZW50KGRvYykge1xuICAgIHZhciBfYSwgX2I7XG4gICAgaWYgKCFmcilcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmluYWxpemF0aW9uUmVnaXN0cnkgbm90IHN1cHBvcnRlZC4nKTtcbiAgICB2YXIgcHJvdmlkZXJSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gICAgdmFyIERleGllWVByb3ZpZGVyID0gRGV4aWVbJ0RleGllWVByb3ZpZGVyJ107XG4gICAgaWYgKCFEZXhpZVlQcm92aWRlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RleGllWVByb3ZpZGVyIGlzIG5vdCBhdmFpbGFibGUuIE1ha2Ugc3VyZSBgeS1kZXhpZWAgaXMgaW5zdGFsbGVkIGFuZCBpbXBvcnRlZC4nKTtcbiAgICB9XG4gICAgdmFyIHVucmVnaXN0ZXJUb2tlbiA9IHVuZGVmaW5lZDtcbiAgICBpZiAoZG9jKSB7XG4gICAgICAgIGlmIChkb2MgIT09ICgoX2EgPSBwcm92aWRlclJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZG9jKSkge1xuICAgICAgICAgICAgcHJvdmlkZXJSZWYuY3VycmVudCA9IERleGllWVByb3ZpZGVyLmxvYWQoZG9jLCB7IGdyYWNlUGVyaW9kOiBncmFjZVBlcmlvZCB9KTtcbiAgICAgICAgICAgIHVucmVnaXN0ZXJUb2tlbiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICBmci5yZWdpc3Rlcihwcm92aWRlclJlZiwgZG9jLCB1bnJlZ2lzdGVyVG9rZW4pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKChfYiA9IHByb3ZpZGVyUmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5kb2MpIHtcbiAgICAgICAgcHJvdmlkZXJSZWYuY3VycmVudCA9IG51bGw7XG4gICAgfVxuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChkb2MpIHtcbiAgICAgICAgICAgIC8vIERvYyBpcyBzZXQgb3IgY2hhbmdlZC4gVW5yZWdpc3RlciBwcm92aWRlciBmcm9tIEZpbmFsaXphdGlvblJlZ2lzdHJ5XG4gICAgICAgICAgICAvLyBhbmQgaW5zdGVhZCB0YWtlIG92ZXIgZnJvbSBoZXJlIHRvIHJlbGVhc2UgdGhlIGRvYyB3aGVuIGNvbXBvbmVudCBpcyB1bm1vdW50ZWRcbiAgICAgICAgICAgIC8vIG9yIHdoZW4gZG9jIGlzIGNoYW5nZWQuIFdoYXQgd2UncmUgZG9pbmcgaGVyZSBpcyB0byBhdm9pZCByZWx5aW5nIG9uIEZpbmFsaXphdGlvblJlZ2lzdHJ5XG4gICAgICAgICAgICAvLyBpbiBhbGwgdGhlIG5vcm1hbCBjYXNlcyBhbmQgaW5zdGVhZCByZWx5IG9uIFJlYWN0J3MgbGlmZWN5Y2xlIHRvIHJlbGVhc2UgdGhlIGRvYy5cbiAgICAgICAgICAgIC8vIEJ1dCB0aGVyZSBjYW4gYmUgc2l0dWF0aW9ucyB3aGVuIHJlYWN0IG5ldmVyIGNhbGxzIHRoaXMgZWZmZWN0IGFuZCB0aGVyZWZvcmUsIHdlXG4gICAgICAgICAgICAvLyBuZWVkIHRvIHJlbHkgb24gRmluYWxpemF0aW9uUmVnaXN0cnkgdG8gcmVsZWFzZSB0aGUgZG9jIGFzIGEgZmFsbGJhY2suXG4gICAgICAgICAgICAvLyBXZSBjYW5ub3Qgd2FpdCB3aXRoIGxvYWRpbmcgdGhlIGRvY3VtZW50IHVudGlsIHRoZSBlZmZlY3QgaGFwcGVucywgYmVjYXVzZSB0aGUgZG9jXG4gICAgICAgICAgICAvLyBjb3VsZCBoYXZlIGJlZW4gZGVzdHJveWVkIGluIHRoZSBtZWFudGltZS5cbiAgICAgICAgICAgIGlmICh1bnJlZ2lzdGVyVG9rZW4pXG4gICAgICAgICAgICAgICAgZnIudW5yZWdpc3Rlcih1bnJlZ2lzdGVyVG9rZW4pO1xuICAgICAgICAgICAgdmFyIHByb3ZpZGVyID0gRGV4aWVZUHJvdmlkZXIuZm9yKGRvYyk7XG4gICAgICAgICAgICBpZiAocHJvdmlkZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBEZXhpZVlQcm92aWRlci5yZWxlYXNlKGRvYyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE1heWJlIHRoZSBkb2Mgd2FzIGRlc3Ryb3llZCBpbiB0aGUgbWVhbnRpbWUuXG4gICAgICAgICAgICAgICAgLy8gQ2FuIG5vdCBoYXBwZW4gaWYgUmVhY3QgYW5kIEZpbmFsaXphdGlvblJlZ2lzdHJ5IHdvcmtzIGFzIHdlIGV4cGVjdCB0aGVtIHRvLlxuICAgICAgICAgICAgICAgIC8vIEV4Y2VwdCBpZiBhIHVzZXIgaGFkIGNhbGxlZCBEZXhpZVlQcm92aWRlci5yZWxlYXNlKCkgb24gdGhlIGRvY1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZBVEFMLiBEZXhpZVlQcm92aWRlci5yZWxlYXNlKCkgaGFzIGJlZW4gY2FsbGVkIHNvbWV3aGVyZSBpbiBhcHBsaWNhdGlvbiBjb2RlLCBtYWtpbmcgdXMgbG9zZSB0aGUgZG9jdW1lbnQuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW2RvYywgdW5yZWdpc3RlclRva2VuXSk7XG4gICAgcmV0dXJuIHByb3ZpZGVyUmVmLmN1cnJlbnQ7XG59XG5cbmV4cG9ydCB7IHVzZURvY3VtZW50LCB1c2VMaXZlUXVlcnksIHVzZU9ic2VydmFibGUsIHVzZVBlcm1pc3Npb25zIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZXhpZS1yZWFjdC1ob29rcy5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/dexie-react-hooks/dist/dexie-react-hooks.mjs\n");

/***/ })

};
;